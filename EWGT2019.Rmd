---
title: "EWGT2019"
author: "Dmitry Pavlyuk"
date: "February 6, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

This markdown document reproduces the research "Ensemble learning of the spatiotemporal structure of urban traffic
flows", submitted to EURO Working Group on Transportation Meeting, EWGT 2019

Load necessary libraries
----------------
```{r libs}
memory.limit(size=1024*128)
library(needs)
needs(tidyverse)
needs(reshape2)
needs(ggplot2)
needs(geosphere)
needs(igraph)
needs(Metrics)
needs(imputeTS)
needs(e1071)
needs(MTS)
needs(forecast)
needs(doParallel)

source(file.path("R","prepare_data_functions.R"))
source(file.path("R","cv_functions.R"))
source(file.path("R","cv_utils.R"))
source(file.path("R","models_util.R"))
source(file.path("R","models_baseline.R"))
source(file.path("R","models_spvar.R"))
```


```{r child = 'sampling.Rmd'}
```

```{r model}
series <- colnames(mysample$data)[-1]
print(paste("Number of series", length(series)))

trainingMinutes <- seq(480,480, by=120)
validationSize <- 7*24*60/ta
validationEnd <- nrow(mysample$data)
validationStart <- validationEnd - validationSize
forecastEvery<-480
forecastingSteps<-3 #12/ta
trainingSize <- trainingMinutes[1]/ta

lagMatrix <- round(mysample$shortest.distances / ta)
lagMatrix[is.infinite(lagMatrix)]<-0
rownames(lagMatrix)<-paste0(rownames(lagMatrix),".volume")
colnames(lagMatrix)<-paste0(colnames(lagMatrix),".volume")
lagMatrix<-lagMatrix[as.vector(series),as.vector(series)]

dat.restricted<-mysample$data[(validationStart-trainingSize+1):validationEnd,]
base_params<-list(data=dat.restricted, seriesNames=series, forecastingSteps=forecastingSteps, forecastEvery=forecastEvery)
params<-c(base_params,list(trainingWindowSize=trainingSize))

  results<-tibble()
  res<-do.call(rollingWindow,
               c(params,list(xModel=xModel.naive)),
               envir=environment())
  results<-bind_rows(results,res)

  
  res<-do.call(rollingWindow,
               c(params,list(xModel=xModel.zero)),
               envir=environment())
  results<-bind_rows(results,res)
  
  res<-do.call(rollingWindow,
               c(params,list(xModel=xModel.mean)),
               envir=environment())
  results<-bind_rows(results,res)
  
  res<-do.call(rollingWindow,
               c(params,list(xModel=xModel.ma)),
               envir=environment())
  results<-bind_rows(results,res)
  
  res<-do.call(rollingWindow,
               c(params,list(xModel=xModel.autoarima)),
               envir=environment())
  results<-bind_rows(results,res)
  
  
  
  res<-do.call(rollingWindow,
               c(params,list(xModel=suf(xModel.star,"CCF"),matrixMode="CCF",
                             control=list(ccfThreshold=0.3),
                             arLags=3,include.mean=F)),
               envir=environment())
  results<-bind_rows(results,res)
  
  res<-do.call(rollingWindow,
               c(params,list(xModel=suf(xModel.star,"travelTime"),matrixMode="travelTime",
                             control=list(lagMatrix=lagMatrix),
                             arLags=3,include.mean=F)),
               envir=environment())
  results<-bind_rows(results,res)
  
  
  source(file.path("R","cv_functions.R"))
  source(file.path("R","models_spvar.R"))
  
  results<-tibble()
  
  
  
  
  ccfThresholds <- c(0.3)#seq(0.1,0.9, by=0.8)
  glassoRhos <- c(0.1, 0.3)#seq(0.1,0.9, by=0.8)
  means <- c(F)
  ar_orders <- c(1, 3)
  
  
  file.remove("fs.rds")
  
  source(file.path("R","models_spvar.R"))
  
  source(file.path("R","cv_functions.R"))
  
  cvgrid <- expand.grid(glassoRho = glassoRhos, include.mean = means, arLags = ar_orders)
  for (r in 1:nrow(cvgrid)){
    cv <- cvgrid[r,]
    print("Tunes parameters:")
    print(cv)
    res<-do.call(rollingWindow,
               c(params,list(xModel=suf(xModel.star,"glasso"),matrixMode="glasso",
                             control=list(glassoRho=cv$glassoRho),
                             arLags=cv$arLags,include.mean=cv$include.mean,save_links_file="fs.rds")),
               envir=environment())
    results<-bind_rows(results,res%>%mutate(arLags=cv$arLags,
                         include.mean=cv$include.mean,glassoRho=cv$glassoRho))
  }
  
  cvgrid <- expand.grid(ccfThreshold=ccfThresholds, glassoRho = glassoRhos, 
                        include.mean = means, arLags = ar_orders)
  for (r in 1:nrow(cvgrid)){
    cv <- cvgrid[r,]
    print("Tunes parameters:")
    print(cv)
    res<-do.call(rollingWindow,
               c(params,list(xModel=suf(xModel.star,"ensemble"),matrixMode=c("glasso","CCF", "travelTime"),
                             control=list(glassoRho=cv$glassoRho,lagMatrix=lagMatrix,ccfThreshold=cv$ccfThreshold),
                             arLags=cv$arLags,include.mean=cv$include.mean,save_links_file="fs.rds")),
               envir=environment())
    results<-bind_rows(results,res%>%mutate(arLags=cv$arLags,
                         include.mean=cv$include.mean,glassoRho=cv$glassoRho,ccfThreshold=cv$ccfThreshold))
  }
  
  cvSummary(results, mae, params=c('arLags','glassoRho','ccfThreshold','include.mean'))
  winners <- cvSummary(results, mae, cumulative=T, params=c('arLags','glassoRho','ccfThreshold','include.mean'))%>%
    filter(forecast_horizon==3)%>%
    mutate(modelid=paste(gsub("STAR ","",model),arLags,glassoRho, ccfThreshold,include.mean))%>%
    group_by(model)%>%filter(MAE==min(MAE))%>%ungroup%>%
    select(modelid)%>%pull
  cvSummary(results, mae, T)
  cvSummary(results, mae)
  
  
  # 
  # needs(glasso)
  # res<-do.call(xModel.star$run,list(sampl=dat.restricted[,series],
  #                                   matrixMode=c("glasso","CCF", "travelTime"),
  #                                   control=list(glassoRho=0.3,lagMatrix=lagMatrix,
  #                                                ccfThreshold=0.1),
  #                             arLags=3,include.mean=F,forecastingSteps=forecastingSteps,
  #                             save_links_file="fs.rds"),
  #               envir=environment())

  fs.tib <- readRDS("fs.rds")
  
  fs.tib%>%filter(value==1)%>%
    mutate(modelid=paste(fs,max_lag,glasso_rho, ccf_threshold,include_mean))%>%
    filter(modelid %in% winners)%>%
    mutate(last_date = as.POSIXct(last_date, "%Y-%m-%d %H:%M:%S",tz="GMT"))%>%
    group_by(modelid,last_date)%>%
    summarise(n=n())%>%arrange(modelid, last_date)%>%
  ggplot(aes(x = last_date, y = n, col=modelid, group=modelid)) + geom_line()
```